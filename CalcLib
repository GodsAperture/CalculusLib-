#include <complex>
#include <iostream>

namespace calculus{
    ////basic assets

    //This function creates a list of `long double` points generated by using the function `fun` evaluated at every point from `start` to `start + size * delta`.
    template<typename T>
    void array(T (*fun)(T), const int size, T arr[], const T delta = 0.1, const T start = 0){

        for(int i = 0; i < size; i++){
            arr[i] = fun(start + i * delta);
        }

    }

    //This function takes a given array `arr` and applies a given function `fun` to every element of the array.
    template<typename T>
    void function(T (*fun)(T), const int size, T arr[]){

        for(int i = 0; i < size; i++){
            arr[i] = fun(arr[i]);
        }

    }

    //This function generates an array of equally spaced points.
    template<typename T>
    void linspace(T arr[], const int size, T start, T end){
        T spacing = (end - start) / (size - 1);

        for(int i = 0; i < size; i++){
            arr[i] = start + i * spacing;
        }

    }

    //This function modifies `arr` and inserts the difference between the (i + 1)th element and the ith element at the ith element along the entire array.
    template<typename T>
    void difference(T arr[], const int size){

        for(int i = 0; i < size - 1; i++){
            arr[i] = arr[i + 1] - arr[i];
        }

    }

    //This function modifies `arr2` and inserts the difference between the (i + 1)th element of `arr` and the ith element of `arr` at the ith element along the entire array.
    template<typename T>
    void difference(T arr[], const int size, T arr2[]){

        for(int i = 0; i < size - 1; i++){
            arr2[i] = arr[i + 1] - arr[i];
        }

    }

    template<typename T>
    T dotProduct(T arr1[], const int size, T arr2[]){
        T sum = 0;

        for(int i = 0; i < size; i++){
            sum += arr1[i] * arr2[i];
        }

        return sum;

    }

    template<typename T>
    //This function returns the AREA of the full trapezoid produced by the two vectors `arr1` and `arr2`, NOT an orthogonal vector.
    T pCross(T arr1[], const int size, T arr2[]){
        T sum = 0;
        T val;

        for(int i = 0; i < size; i++){
            for(int k = i + 1; k < size; k++){
                val = arr1[i] * arr2[k] - arr1[k] * arr2[i];
                sum += val * val;
            }
        }

        return sqrtl(sum);

    }

    template<typename T>
    T magnitude(T arr[], const int size){
        T sum = 0;

        for(int i = 0; i < size; i++){
            sum += arr[i] * arr[i];
        }

        return sqrtl(sum);

    }

    ////matrix related functions

    //This function will print out the matrix of dimensions `dim1`x`dim2`
    template<typename T>
    void printMatrix(T arr[], const int dim1, const int dim2 = 1){

        for(int i = 0; i < dim1; i++){
            for(int k = 0; k < dim2; k++){
                std::cout << arr[k + i * dim2] << " ";
            }
            printf("\n");
        }

    }

    template<typename T>
    //Rewrites `arr` to be the transposed matrix of dimensions `dim2`x`dim1`.
    void transpose(T arr[], const int dim1, const int dim2){
        T temp[dim1 * dim2];

        for(int i = 0; i < dim2; i++){
            for(int k = 0; k < dim1 + 1; k++){

                temp[k + i * dim1] = arr[i + k * dim2];

            }
        }

        for(int i = 0; i < dim1 * dim2; i++){
            arr[i] = temp[i];
        }

    }

    template<typename T>
    //Rewrites `arr` to be the transposed matrix of dimensions `dim2`x`dim1`.
    void transpose(T arr[], const int dim1, const int dim2, T arr2[]){

        for(int i = 0; i < dim2; i++){
            for(int k = 0; k < dim1 + 1; k++){

                arr2[k + i * dim1] = arr[i + k * dim2];

            }
        }

    }

    template<typename T>
    void multiply(T arr1[], const int dim1, const int dim2, const int dim3, T arr2[]){
        T temp[dim1 * dim3];
        T sum = 0;

        for(int i = 0; i < dim1; i++){
            for(int k = 0; k < dim2; k++){
                sum = arr1[k + i * dim1] * arr2[]
            }
        }


    }



    ////Differentiation functions

        ////function based derivatives

    template<typename T>
    T derivative2_1(T (*fun)(T), const T point, const T delta = 0.1) {

        return (fun(point + 0.5 * delta) - fun(point - 0.5 * delta))/ delta;

    }

    template<typename T>
    T derivative2_2(T (*fun)(T), const T point, const T delta = 0.1) {

        return (fun(point + delta) - 2 * fun(point) + fun(point - delta)) / (delta * delta);

    }

    template<typename T>
    T derivative2_3(T (*fun)(T), const T point, const T delta = 0.1) {

        return (fun(point + 1.5 * delta) - 3 * fun(point + 0.5 * delta) + 3 * fun(point - 0.5 * delta) - fun(point - 1.5 * delta)) / (delta * delta * delta);

    }

    template<typename T>
    T derivative2_4(T (*fun)(T), const T point, const T delta = 0.1) {

        return (fun(point + 2 * delta) - 4 * fun(point + delta) + 6 * fun(point) - 4 * fun(point - delta) + fun(point - 2 * delta)) / (delta * delta * delta * delta);

    }

    template<typename T>
    T derivative3_1(T (*fun)(T), const T point, const T delta = 0.1) {

        //I modified the proof to Simpson's rule so that it may be extended to derivatives.
        //These coefficients will produce the approximate derivative of a 3rd degree interpolation.

        return (-0.04166666667 * fun(point + 1.5 * delta) + 1.125 * fun(point + 0.5 * delta) - 1.125 * fun(point - 0.5 * delta) + 0.04166666667 * fun(point - 1.5 * delta)) / delta;
    }

    template<typename T>
    T derivative3_2(T (*fun)(T), const T point, const T delta = 0.1) {

        //These coefficients are the same as nesting derivative3_1 two times.

        return (0.001736111111 * fun(point + 3 * delta) - 0.09375 * fun(point + 2 * delta) + 1.359375 * fun(point + delta) - 2.534722222 * fun(point) - 1.359375 * fun(point - delta) - 0.09375 * fun(point - 2 * delta) + 0.001736111111 * fun(point - 3 * delta)) / (delta * delta);
    }

    template<typename T>
    T derivative3_3(T (*fun)(T), const T point, const T delta = 0.1) {

        //These coefficients are the same as nesting der1 three times.

        return (-0.00007233796296 * fun(point + 4.5 * delta) + 0.005859375 * fun(point + 3.5 * delta) - 0.1640625 * fun(point + 2.5 * delta) + 1.740451389 * fun(point + 1.5 * delta) - 4.44140625 * fun(point + 0.5 * delta) + 4.44140625 * fun(point - 0.5 * delta) - 1.740451389 * fun(point - 1.5 * delta) + 0.1640625 * fun(point - 2.5 * delta) - 0.005859375 * fun(point - 3.5 * delta) + 0.00007233796296 * fun(point - 4.5 * delta)) / (delta * delta * delta);
    }



        ////array based derivatives
////UNFINISHED
    template<typename T1, typename T2>
    void derivative3_1(const T1 arr[], int size, T2 arr2[], const T2 delta = 0.1){
        const T2 coe = 1 / delta;

        arr2[0] = coe * (-1.833333333333333 * arr[0] + 3 * arr[1] - 1.5 * arr[2] + 0.3333333333333333 * arr[3]);
        arr2[1] = coe * (-0.3333333333333333 * arr[0] - 0.5 * arr[1] + arr[2] - 0.1666666666666667 * arr[3]);
        arr2[2] = coe * (0.1666666666666667 * arr[0] - arr[1] + 0.5 * arr[2] + 0.3333333333333333 * arr[3]);
        arr2[3] = coe * (-0.3333333333333333 * arr[0] + 1.5 * arr[1] - 3 * arr[2] + 1.8333333333333333 * arr[3]);

        for(int i = 4; i < size - 4; i++){
            arr2[i] = coe * (-0.3333333333333333 * arr[i-1] - 0.5 * arr[i] + arr[i+1] - 0.1666666666666667 * arr[i+2]);
        }

        arr2[size - 4] = coe * (-1.833333333333333 * arr[size - 4] + 3 * arr[size - 3] - 1.5 * arr[size - 2] + 0.3333333333333333 * arr[size - 1]);
        arr2[size - 3] = coe * (-0.3333333333333333 * arr[size - 4] - 0.5 * arr[size - 3] + arr[size - 2] - 0.1666666666666667 * arr[size - 1]);
        arr2[size - 2] = coe * (0.1666666666666667 * arr[size - 4] - arr[size - 3] + 0.5 * arr[size - 2] + 0.3333333333333333 * arr[size - 1]);
        arr2[size - 1] = coe * (-0.3333333333333333 * arr[size - 4] + 1.5 * arr[size - 3] - 3 * arr[size - 2] + 1.8333333333333333 * arr[size - 1]);

    }

////UNFINISHED
    template<typename T>
    void derivative3_1(T arr[], int size, const T delta = 0.1){
        const T coe = 1 / delta;
        T temp = arr[0];
        T atemp;

        T temp1 = arr[1];
        T temp2 = arr[2];
        T temp3 = arr[3];
        T temp4;
        T temp5;

        for(int i = 1; i < size - 4; i++){
            atemp = arr[i];

            arr[i] = coe * (-0.3333333333333333 * temp - 0.5 * arr[i] + arr[i + 1] - 0.1666666666666667 * arr[i + 2]);

            temp = atemp;
        }

        arr[0] = coe * (-1.833333333333333 * arr[0] + 3 * temp1 - 1.5 * temp2 + 0.3333333333333333 * temp3);

        temp1 = arr[size - 6];
        temp2 = arr[size - 5];
        temp3 = arr[size - 4];
        temp4 = arr[size - 3];
        temp5 = arr[size - 2];



    }



        ////function to array based differentiation

            ////spanned differentiation

    template<typename T>
    void derivative2_1(T (*fun)(T), T arr[], const int size, const T delta = 0.1, const T start = 0, const T span = 0.1){
        const T coe = 1 / delta;
        const T space = span + delta;
        const T val1 = 0.5 * delta;

        for(int i = 0; i < size; i++){
            arr[i] = coe * (fun(start + val1 + i * space) - fun(start - val1 + i * space));
        }

    }

    template<typename T>
    void derivative2_2(T (*fun)(T), T arr[], const int size, const T delta = 0.1, const T start = 0, const T span = 0.1){
        const T coe = 1 / delta;
        const T space = span + delta;
        const T coe2 = coe * coe;

        for(int i = 0; i < size; i++){
            arr[i] = coe2 * (fun(start + delta + i * space) - 2 * fun(start + i * space) + fun(start - delta + i * space));
        }

    }

    template<typename T>
    void derivative2_3(T (*fun)(T), T arr[], const int size, const T delta = 0.1, const T start = 0, const T span = 0.1){
        const T coe = 1 / delta;
        const T space = span + delta;
        const T coe3 = coe * coe * coe;
        const T val1 = 0.5 * delta;
        const T val2 = 1.5 * delta;


        for(int i = 0; i < size; i++){
            arr[i] = coe3 * (fun(start + val2 + i * space) - 3 * fun(start + val1 + i * space) + 3 * fun(start - val1 + i * space) - fun(start - val2 + i * space));
        }

    }

            ////spanless differentiaton

    template<typename T>
    void derivative2_1(T (*fun)(T), const int size, T arr[], const T delta = 0.1, const T start = 0){
        const T coe = 1 / delta;
        const T temp1 = fun(start - 0.5 * delta);
        const T temp2 = fun(start + 0.5 * delta);

        for(int i = 0; i < size; i++){
            arr[i] = coe * (temp1 - temp2);

            temp1 = temp2;
            temp2 = fun(start + (i + 1.5) * delta);
        }

    }

    template<typename T>
    void derivative2_2(T (*fun)(T), const int size, T arr[], const T delta = 0.1, const T start = 0){
        const T coe = 1 / delta;
        const T coe2 = coe * coe;
        T temp1 = fun(start - delta);
        T temp2 = fun(start);
        T temp3 = fun(start + delta);

        for(int i = 0; i < size; i++){
            arr[i] = coe2 * (temp3 - 2 * temp2 + temp1);

            temp1 = temp2;
            temp2 = temp3;
            temp3 = fun(start + (i + 2) * delta);
        }

    }

    template<typename T>
    void derivative3_1(T (*fun)(T), const int size, T arr[], const T delta = 0.1, const T start = 0){
        const T coe = 1 / delta;
        T temp1 = fun(start - 1.5 * delta);
        T temp2 = fun(start - 0.5 * delta);
        T temp3 = fun(start + 0.5 * delta);
        T temp4 = fun(start + 1.5 * delta);

        for(int i = 0; i < size; i++){
            arr[i] = coe * (0.0416666666666667 * temp1 - 1.125 * temp2 + 1.125 * temp3 - 0.0416666666666667 * temp4);

            temp1 = temp2;
            temp2 = temp3;
            temp3 = temp4;
            temp4 = fun(start + (i + 2.5) * delta);
        }

    }

    ////Integration functions

        ////function based integrals



            ////long double data type

    template<typename T>
    T integral1(T (*fun)(T), const T low, const T up, const T delta = 0.1){
        T sum = 0;
        const int length = (up - low) / delta;
        const T diff = up - low - length * delta;

        T var = low;

        T old1 = 0.125 * fun(var);

        for(int i = 0; i < length; i+= 1){
            sum += old1 + 0.375 * fun(var + (i + 0.3333333333333333) * delta) + 0.375 * fun(var + (i + 0.6666666666666667) * delta);
            //Commented code below was merged with the prior line.
            //sum += 0.375 * fun(var + (i + 0.3333333333333333) * delta);
            //sum += 0.375 * fun(var + (i + 0.6666666666666667) * delta);

            old1 = 0.125 * fun(var + (i + 1) * delta);

            sum += old1;
        }

        var = up;

        return delta * sum + diff * (0.125 * fun(var - diff) + 0.375 * fun(var - 0.6666666666666667 * diff) + 0.375 * fun(var - 0.3333333333333333 * diff) + 0.125 * fun(var));
    }


    ////ODE solvers (non-DSAE)
    ////Removed from public view for now.

};
